#!/usr/bin/python
# encoding=UTF-8

# Copyright © 2013 Jakub Wilk <jwilk@jwilk.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 dated June, 1991.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.

'''
hocr-corpus takes two or more hOCR files for the same document, and merges them
into one XCES (the IPI PAN variant) corpus.

Only hOCR files generated by Tesseract >= 3.02 (possibly concatenated with
hocr-concat) are supported.
'''

# Utility suggested by Janusz S. Bień

from __future__ import print_function

import argparse
import sys

import bcp47
import hocr
import logger
import uax29
import xmlutils

xces_top = '''\
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE cesAna SYSTEM "xcesAnaIPI.dtd">
<cesAna version="IPI-1.2">
<chunkList>
'''

xces_bottom = '''\
</chunkList>
</cesAna>
'''

class XcesMerger(hocr.Merger):

    def __init__(self, options):
        hocr.Merger.__init__(self, options)
        class context: pass
        self.context = context
        self.context.tail = None

    def merge(self, elements):
        elements = list(elements)
        base_element = elements[0]
        classes = list(
            cls.split('_', 1)[1]
            for cls in base_element.get('class', '').split()
            if cls.startswith(('ocr_', 'ocrx_'))
        )
        is_word = 'word' in classes
        if is_word:
            classes.remove('word')
        for cls in classes:
            print('<chunk type={type}>'.format(type=xmlutils.quoteattr(cls)))
            self.context.tail = True # <ns/> is never needed at the beginning of a chunk
        hocr.Merger.merge(self, elements)
        for cls in reversed(classes):
            print('</chunk>')

    def merge_words(self, elements):
        # TODO: Add support for UAX#29.
        elements = list(elements)
        base_element = elements[0]
        base_title_pattern = hocr.parse_title(base_element)[0]
        max_wconf = -1
        max_element = None
        welements = {}
        split_lengths = set()
        for element in elements:
            title_pattern, bbox, wconf = hocr.parse_title(element)
            if title_pattern != base_title_pattern:
                logger.error("error: unable to merge hOCR because attributes differ")
                for e in base_element, element:
                    logger.error("- {loc}: {elem} attribute 'title' is {value!r}",
                        loc=xmlutils.location(e),
                        elem=xmlutils.repr(e),
                        value=e.get('title'),
                    )
            text_element, text, formatting = self.get_text_info(element)
            if not text:
                # TODO: Implement a better strategy for dealing with empty words.
                logger.warning('warning: empty word; replacing with OBJECT REPLACEMENT CHARACTER')
                logger.warning("- {loc}: {elem}",
                    loc=xmlutils.location(element),
                    elem=xmlutils.repr(element),
                )
                text = u'\N{OBJECT REPLACEMENT CHARACTER}'
            tag = 'ign'
            lang = element.get('lang')
            if lang:
                langtag = bcp47.LanguageTag.from_tesseract(lang)
            else:
                langtag = bcp47.LanguageTag('und')
            tag += ':{lang}'.format(lang=langtag.language)
            if langtag.script:
                tag += ':{script}'.format(script=langtag.script.lower())
            tag += ':{series}'.format(series=['medium', 'bold']['strong' in formatting])
            tag += ':{shape}'.format(shape=['upright', 'italic']['em' in formatting])
            tag += ':{wconf}'.format(wconf = wconf//10 if wconf < 90 else '9')
            if self.options.uax29:
                locale = langtag.get_locale()
                split_text = tuple(
                    text
                    for text, bbox
                    in uax29.split_bbox(text, bbox, locale=locale)
                )
            else:
                split_text = (text,)
            split_lengths.add(len(split_text))
            # TODO: Add font attribute.
            try:
                prev_wconf = welements[(split_text, tag)]
            except LookupError:
                welements[(split_text, tag)] = wconf
            else:
                welements[(split_text, tag)] = max(wconf, prev_wconf)
            # TODO: Check if bounding boxes are matching.
            if wconf > max_wconf:
                max_wconf = wconf
                max_element = element
                max_tuple = (max_split_text, max_tag) = (split_text, tag)
        if not self.context.tail:
            print('<ns/>')
        if len(split_lengths) > 1:
            if len(max_tuple[0]) == 1:
                # Unsplit:
                welements = dict(
                    (((''.join(split_text),), tag), wconf)
                    for (split_text, tag), wconf
                    in welements.items()
                )
                split_length = 1
            else:
                logger.warning('warning: inconsistent segmentation')
                for e in elements:
                    _, text, _ = self.get_text_info(e)
                    split_text = list(
                        text
                        for text, bbox
                        in uax29.split_bbox(text, bbox, locale=locale)
                    )
                    logger.error("- {loc}: {elem} {status} text {text!r} -> {split!r}",
                        loc=xmlutils.location(e),
                        elem=xmlutils.repr(e),
                        status=('accepted' if e is max_element else 'rejected'),
                        text=text,
                        split=split_text,
                    )
                welements = {max_tuple: welements[max_tuple]}
                split_length = len(max_split_text)
        else:
            [split_length] = split_lengths
        has_disamb = False
        for i in xrange(split_length):
            if i > 0:
                print('<ns/>')
            print('<tok>')
            print('<orth>{orth}</orth>'.format(orth=xmlutils.escape(max_split_text[i])))
            for (split_text, tag), wconf in welements.iteritems():
                disamb = wconf == max_wconf
                if disamb:
                    has_disamb = True
                print('<lex disamb="{disamb}"><base>{base}</base><ctag>{tag}</ctag></lex>'.format(
                    disamb=int(disamb),
                    base=xmlutils.escape(split_text[i]),
                    tag=xmlutils.escape(tag),
                ))
            print('</tok>')
            assert has_disamb, welements
        self.context.tail = bool(base_element.tail)

def main():
    ap = argparse.ArgumentParser(description=__doc__.strip())
    ap.add_argument('files', metavar='HOCR-FILE', nargs='+', help='hOCR files to merge')
    ap.add_argument('--uax29', action='store_true', help='split words using the UAX#29 algorithm')
    options = ap.parse_args()
    trees = []
    for path in options.files:
        try:
            trees += [hocr.parse(path)]
        except hocr.XMLSyntaxError:
            sys.exit(1)
    merger = XcesMerger(options)
    print(xces_top, end='')
    try:
        merger.merge([t.getroot() for t in trees])
    except hocr.MergeError:
        sys.exit(1)
    print(xces_bottom, end='')

if __name__ == '__main__':
    main()

# vim:ts=4 sw=4 et
