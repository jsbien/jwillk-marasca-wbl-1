#!/usr/bin/python
# encoding=UTF-8

# Copyright Â© 2013 Jakub Wilk <jwilk@jwilk.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 dated June, 1991.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.

'''
hocr-corpus takes two or more hOCR files for the same document, and merges them
into one XCES (the IPI PAN variant) corpus.

Only hOCR files generated by Tesseract >= 3.02 (possibly concatenated with
hocr-concat) are supported.
'''

from __future__ import print_function

import argparse
import sys

from lxml import etree

import bcp47
import hocr
import logger
import xmlutils

xces_top = '''\
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE cesAna SYSTEM "xcesAnaIPI.dtd">
<cesAna version="IPI-1.2">
<chunkList>
'''

xces_bottom = '''\
</chunkList>
</cesAna>
'''

class XcesMerger(hocr.Merger):

    def __init__(self, options):
        hocr.Merger.__init__(self, options)
        class context: pass
        self.context = context
        self.context.tail = None

    def merge(self, elements):
        elements = list(elements)
        base_element = elements[0]
        classes = list(
            cls.split('_', 1)[1]
            for cls in base_element.get('class', '').split()
            if cls.startswith(('ocr_', 'ocrx_'))
        )
        is_word = 'word' in classes
        if is_word:
            classes.remove('word')
        for cls in classes:
            print('<chunk type={type}>'.format(type=xmlutils.quoteattr(cls)))
            self.context.tail = True # <ns/> is never needed at the beginning of a chunk
        hocr.Merger.merge(self, elements)
        for cls in reversed(classes):
            print('</chunk>')

    def merge_words(self, elements):
        # TODO: Add support for UAX#29.
        elements = list(elements)
        base_element = elements[0]
        base_title_pattern = hocr.parse_title(base_element)[0]
        max_wconf = -1
        max_element = None
        welements = {}
        for element in elements:
            try:
                del element.attrib['id'] # merging could cause duplicate identifiers
            except LookupError:
                pass
            title_pattern, bbox, wconf = hocr.parse_title(element)
            if title_pattern != base_title_pattern:
                logger.error("error: unable to merge hOCR because attributes differ")
                for e in base_element, element:
                    logger.error("- {loc}: {elem} attribute 'title' is {value!r}",
                        loc=xmlutils.location(e),
                        elem=xmlutils.repr(e),
                        value=e.get('title'),
                    )
            text = self.get_text(element)
            if not text:
                # TODO: Implement a better strategy for dealing with empty words.
                logger.warning('warning: empty word; replacing with OBJECT REPLACEMENT CHARACTER')
                logger.warning("- {loc}: {elem}",
                    loc=xmlutils.location(element),
                    elem=xmlutils.repr(element),
                )
                text = u'\N{OBJECT REPLACEMENT CHARACTER}'
            tag = 'ign'
            lang = element.get('lang')
            if lang:
                lang = bcp47.from_tesseract(lang)
                tag += ':' + lang
            # TODO: Add font attribute.
            try:
                prev_wconf = welements[(text, tag)]
            except LookupError:
                welements[(text, tag)] = wconf
            else:
                welements[(text, tag)] = max(wconf, prev_wconf)
            # TODO: Check if bounding boxes are matching.
            if wconf > max_wconf:
                max_wconf = wconf
                max_element = element
        if not self.context.tail:
            print('<ns/>')
        print('<tok>')
        text = self.get_text(max_element)
        if not text:
            text = u'\N{OBJECT REPLACEMENT CHARACTER}'
        print('<orth>{orth}</orth>'.format(orth=xmlutils.escape(text)))
        for (text, tag), wconf in welements.iteritems():
            print('<lex disamb="{disamb}"><base>{base}</base><ctag>{tag}</ctag></lex>'.format(
                disamb=int(wconf == max_wconf),
                base=xmlutils.escape(text),
                tag=xmlutils.escape(tag),
            ))
        print('</tok>')
        self.context.tail = bool(base_element.tail)

def main():
    ap = argparse.ArgumentParser(description=__doc__.strip())
    ap.add_argument('files', metavar='HOCR-FILE', nargs='+', help='hOCR files to merge')
    options = ap.parse_args()
    trees = []
    for path in options.files:
        trees += [etree.parse(path)]
    merger = XcesMerger(options)
    print(xces_top, end='')
    try:
        root = merger.merge([t.getroot() for t in trees])
    except hocr.MergeError:
        sys.exit(1)
    print(xces_bottom, end='')

if __name__ == '__main__':
    main()

# vim:ts=4 sw=4 et
