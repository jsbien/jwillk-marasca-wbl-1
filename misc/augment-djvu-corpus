#!/usr/bin/python
# encoding=UTF-8

# Copyright Â© 2010, 2011 Jakub Wilk <jwilk@jwilk.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 dated June, 1991.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.

'''
Augment Poliqarp binary corpus with information about segment coordinates.
'''

from __future__ import with_statement

import argparse
import os
import re
import struct
import sys

import lxml.etree as etree

bbox_re = re.compile(
    r'''
        bbox \s+
        (?P<x0> -?\d+) \s+
        (?P<y0> -?\d+) \s+
        (?P<x1> -?\d+) \s+
        (?P<y1> -?\d+)
    ''', re.VERBOSE)

default_poliqarp_config = \
'''
[attr]

[pos]
ign =

[named-entity]
entity-orth = orth
entity-base = base
entity-tag = tag
entity-pos = pos
'''

class ArgumentParser(argparse.ArgumentParser):

    def __init__(self):
        usage = '%(prog)s [option...] <base-name> <hocr-file...>'
        argparse.ArgumentParser.__init__(self, usage=usage, description=__doc__)
        self.add_argument('--flip', action='store_true', help='flip hOCR vertically (to work around buggy djvu2hocr)')
        self.add_argument('--append', action='store_true', help='append data to the existing corpus')
        self.add_argument('base', help='corpus basename')
        self.add_argument('files', nargs='+', help='hOCR files')

def process_files(options):

    def try_create_file(suffix, append_ok=True):
        name = '%s.%s' % (options.base, suffix)
        mode = 'w'
        if os.path.exists(name) and os.path.getsize(name) > 0:
            if options.append and append_ok:
                mode = 'a'
            else:
                print >>sys.stderr, 'Not overwriting %s' % name
                name = os.devnull
        return open(name, mode)

    f_config = try_create_file('cfg', append_ok=False)
    f_filenames = try_create_file('djvu.filenames')
    f_coordinates = try_create_file('djvu.coordinates')
    f_pagesizes = try_create_file('djvu.pagesizes')

    f_config.write(default_poliqarp_config)
    n0 = n = 0
    page_height = None
    for filename in options.files:
        print >>sys.stderr, 'Processing %s' % filename
        print >>f_filenames, filename
        hocr = etree.iterparse(filename, ('start', 'end'))
        for event, elem in hocr:
            classes = (elem.get('class') or '').split()
            if event == 'end' and 'ocrx_word' in classes:
                title = elem.get('title')
                m = bbox_re.search(title)
                if m is None:
                    raise ValueError('segment without a bounding box')
                bbox = [min(max(0, int(x)), 0xffff) for x in m.groups()]
                if not options.flip:
                    # (0, 0) is a top-left corner in hOCR,
                    # but bottom-left corner in DjVu.
                    bbox[1], bbox[3] = page_height - bbox[3], page_height - bbox[1]
                bbox = ''.join((struct.pack('< HHHH', *bbox)))
                f_coordinates.write(bbox)
                n += 1
            if event == 'start' and 'ocr_page' in classes:
                title = elem.get('title')
                m = bbox_re.search(title)
                bbox = [min(max(0, int(x)), 0xffff) for x in m.groups()]
                page_height = bbox[-1]
                bbox = ''.join((struct.pack('< I HH', n0, *bbox[-2:])))
                f_pagesizes.write(bbox)
                n0 = n
            if event == 'end':
                elem.clear()

def main():
    oparser = ArgumentParser()
    options = oparser.parse_args()
    process_files(options)

if __name__ == '__main__':
    main()

# vim:ts=4 sw=4 et
